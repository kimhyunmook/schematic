import { Tree, SchematicContext } from "@angular-devkit/schematics";

export interface PrismaModelField {
    name: string;
    type: string;
    optional: boolean;
    description?: string;
    isArray?: boolean;
    isId?: boolean;
    isAutoGenerated?: boolean;
}

export interface PrismaModel {
    name: string;
    fields: PrismaModelField[];
    moduleName?: string;
    enums?: string[]; // ìŠ¤í‚¤ë§ˆì— ì •ì˜ëœ enum íƒ€ì… ëª©ë¡
}

/**
 * Prisma ìŠ¤í‚¤ë§ˆ íŒŒì¼ì—ì„œ ëª¨ë¸ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
 * ëª¨ë“ˆ ì´ë¦„ê³¼ ì¼ì¹˜í•˜ëŠ” ëª¨ë¸ì„ ìš°ì„ ì ìœ¼ë¡œ ì°¾ê³ , ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ ëª¨ë¸ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
export function parsePrismaModel(
    tree: Tree,
    context: SchematicContext,
    prismaPath: string,
    targetModelName?: string
): PrismaModel | undefined {
    const buf = tree.read(prismaPath);
    if (!buf) {
        context.logger.warn(`Could not read prisma file: ${prismaPath}`);
        return undefined;
    }

    const text = buf.toString("utf-8");

    // íŒŒì¼ ìƒë‹¨ì˜ /// ì£¼ì„ì—ì„œ MODULE_NAME ì¶”ì¶œ
    const moduleName = extractModuleNameFromComment(text);

    // ëª¨ë“  enum ì •ì˜ ì°¾ê¸°
    const enums = extractEnums(text);
    context.logger.debug(`Found enums: ${enums.join(", ") || "none"}`);

    // ëª¨ë“  ëª¨ë¸ ë¸”ë¡ ì°¾ê¸°
    const allModelRegex = /model\s+(\w+)\s+\{([\s\S]*?)\}/gm;
    const models: Array<{ name: string; body: string }> = [];
    let match;

    while ((match = allModelRegex.exec(text)) !== null) {
        if (match[1] && match[2]) {
            models.push({
                name: match[1],
                body: match[2],
            });
        }
    }

    if (models.length === 0) {
        context.logger.warn(`No model block found in ${prismaPath}`);
        return undefined;
    }

    // íƒ€ê²Ÿ ëª¨ë¸ ì´ë¦„ì´ ìˆìœ¼ë©´ í•´ë‹¹ ëª¨ë¸ ì°¾ê¸°
    let selectedModel = models[0];

    if (!selectedModel) {
        context.logger.warn(`No model found in ${prismaPath}`);
        return undefined;
    }

    if (targetModelName) {
        // í•˜ì´í”ˆì„ ì œê±°í•˜ê³  PascalCaseë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
        const toPascalCase = (str: string) => {
            return str
                .split('-')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join('');
        };

        const pascalCaseTarget = toPascalCase(targetModelName);

        const found = models.find(
            (m) =>
                m.name.toLowerCase() === targetModelName.toLowerCase() ||
                m.name.toLowerCase() === targetModelName.toLowerCase() + "s" ||
                m.name.toLowerCase() + "s" === targetModelName.toLowerCase() ||
                m.name === pascalCaseTarget ||
                m.name.toLowerCase() === pascalCaseTarget.toLowerCase()
        );
        if (found) {
            selectedModel = found;
            context.logger.info(
                `âœ… Found matching model '${found.name}' for '${targetModelName}'`
            );
        } else {
            context.logger.warn(
                `âš ï¸  No model matching '${targetModelName}' found. Using first model '${selectedModel.name}'`
            );
        }
    }

    const fields: PrismaModelField[] = parseModelFields(
        selectedModel.body,
        context,
        enums
    );

    context.logger.info(
        `âœ… Parsed model '${selectedModel.name}' with ${fields.length} field(s)`
    );

    if (moduleName) {
        context.logger.info(`ğŸ“ Module name extracted from comment: ${moduleName}`);
    }

    const result: PrismaModel = {
        name: selectedModel.name,
        fields,
    };

    if (enums.length > 0) {
        result.enums = enums;
    }

    if (moduleName) {
        result.moduleName = moduleName;
    }

    return result;
}

/**
 * Prisma ìŠ¤í‚¤ë§ˆì—ì„œ enum ì •ì˜ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.
 * ì¤‘ì²©ëœ ì¤‘ê´„í˜¸ë¥¼ ì˜¬ë°”ë¥´ê²Œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
 */
function extractEnums(text: string): string[] {
    const enums: string[] = [];
    const lines = text.split(/\r?\n/);
    let currentEnum: string | null = null;
    let braceCount = 0;
    let inEnum = false;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (!line) continue;
        const trimmed = line.trim();

        // enum í‚¤ì›Œë“œë¡œ ì‹œì‘í•˜ëŠ” ë¼ì¸ ì°¾ê¸°
        const enumMatch = trimmed.match(/^enum\s+(\w+)\s*\{/);
        if (enumMatch && enumMatch[1]) {
            if (currentEnum) {
                // ì´ì „ enumì´ ì™„ë£Œë˜ì§€ ì•Šì•˜ë‹¤ë©´ ì €ì¥
                enums.push(currentEnum);
            }
            currentEnum = enumMatch[1];
            braceCount = 1;
            inEnum = true;
            continue;
        }

        // enum ë‚´ë¶€ì— ìˆì„ ë•Œ ì¤‘ê´„í˜¸ ì¹´ìš´íŠ¸
        if (inEnum && currentEnum) {
            // ì¤‘ê´„í˜¸ ì¹´ìš´íŠ¸
            for (const char of line) {
                if (char === '{') braceCount++;
                if (char === '}') braceCount--;
            }

            // ì¤‘ê´„í˜¸ê°€ ëª¨ë‘ ë‹«í˜”ìœ¼ë©´ enum ì™„ë£Œ
            if (braceCount === 0) {
                enums.push(currentEnum);
                currentEnum = null;
                inEnum = false;
            }
        }
    }

    return enums;
}

/**
 * ëª¨ë¸ ë³¸ë¬¸ì—ì„œ í•„ë“œë“¤ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
function parseModelFields(
    body: string,
    context: SchematicContext,
    enums: string[] = []
): PrismaModelField[] {
    const fields: PrismaModelField[] = [];
    const lines = body.split(/\r?\n/);
    // ìˆ˜ì •ëœ ì •ê·œì‹: íƒ€ì…ì—ì„œ ?ë¥¼ ì œê±°í•˜ê³  ë³„ë„ë¡œ ì²´í¬
    const lineRegex = /^\s*(\w+)\s+([A-Za-z_][A-Za-z0-9_]*)(\[\])?\??/;

    // Prisma scalar íƒ€ì… ì •ì˜
    const scalarTypes = [
        "String",
        "Int",
        "Float",
        "Decimal",
        "BigInt",
        "Boolean",
        "DateTime",
        "Json",
        "Bytes",
    ];

    function getBaseType(type: string): string {
        return type.endsWith("[]") ? type.slice(0, -2) : type.replace("?", "");
    }

    for (const line of lines) {
        const trimmed = line.trim();

        // ë¹ˆ ì¤„, ì£¼ì„, ë°ì½”ë ˆì´í„° ìŠ¤í‚µ
        if (
            !trimmed ||
            trimmed.startsWith("//") ||
            trimmed.startsWith("@@") ||
            trimmed.startsWith("}")
        ) {
            continue;
        }

        const m = trimmed.match(lineRegex);
        if (!m) {
            continue;
        }

        const fName = m[1] ?? "";
        const fType = m[2] ?? "any";
        const hasArray = Boolean(m[3]);

        // ? ìœ„ì¹˜ í™•ì¸ìœ¼ë¡œ optional íŒë³„
        const hasOptional = trimmed.includes("?");
        const optionalPos = trimmed.indexOf("?");
        const arrayPos = trimmed.indexOf("[]");
        // String[]? ëŠ” optional, String? ë„ optional
        const isOptional = hasOptional && (!hasArray || optionalPos > arrayPos);
        const isArray = hasArray;

        // ë¦´ë ˆì´ì…˜ í•„ë“œ ìŠ¤í‚µ (ëŒ€ë¬¸ìë¡œ ì‹œì‘í•˜ëŠ” íƒ€ì… + @relation ìˆëŠ” ê²½ìš°)
        if (/\@relation\b/.test(trimmed)) {
            context.logger.debug(`Skipping relation field: ${fName}`);
            continue;
        }

        // ë² ì´ìŠ¤ íƒ€ì… ì¶”ì¶œ
        const baseType = getBaseType(fType);

        // enum íƒ€ì… ì²´í¬
        const isEnumType = enums.includes(fType) || enums.includes(baseType);

        // ë¦´ë ˆì´ì…˜ íƒ€ì… í•„ë“œ ìŠ¤í‚µ (Prisma scalar íƒ€ì…ë„ ì•„ë‹ˆê³  enumë„ ì•„ë‹Œ ê²½ìš°)
        if (!scalarTypes.includes(fType) && !scalarTypes.includes(baseType) && !isEnumType) {
            context.logger.debug(
                `Skipping non-scalar/non-enum field: ${fName} (type: ${fType})`
            );
            continue;
        }

        // enum íƒ€ì…ì¸ ê²½ìš° ë¡œê¹…
        if (isEnumType) {
            context.logger.debug(`Found enum field: ${fName} (type: ${fType})`);
        }

        // @id ì†ì„± ì²´í¬
        const isId = /@id\b/.test(trimmed);

        // @default ë˜ëŠ” @updatedAt ì²´í¬ (ìë™ ìƒì„± í•„ë“œ)
        const isAutoGenerated =
            /@default\b/.test(trimmed) || /@updatedAt\b/.test(trimmed);

        // ì¸ë¼ì¸ ì£¼ì„ ì¶”ì¶œ (/// ë˜ëŠ” //)
        let description: string | undefined;
        const tripleSlashMatch = trimmed.match(/\/\/\/\s*(.+)$/);
        const doubleSlashMatch = trimmed.match(/\/\/\s*(.+)$/);

        if (tripleSlashMatch) {
            description = tripleSlashMatch[1]?.trim();
        } else if (doubleSlashMatch) {
            description = doubleSlashMatch[1]?.trim();
        }

        const field: PrismaModelField = {
            name: fName,
            type: isArray ? `${fType}[]` : fType,
            optional: isOptional,
            isArray,
            isId,
            isAutoGenerated,
        };

        if (description) {
            field.description = description;
        }

        fields.push(field);
        context.logger.debug(
            `âœ“ Parsed field: ${fName} (${fType}${isOptional ? "?" : ""}) - ${description || "no description"}`
        );
    }

    context.logger.info(`ğŸ“‹ Total fields parsed: ${fields.length}`);
    return fields;
}

/**
 * í”„ë¦¬ì¦ˆë§ˆ íŒŒì¼ ìƒë‹¨ì˜ /// ì£¼ì„ì—ì„œ MODULE_NAMEì„ ì¶”ì¶œí•©ë‹ˆë‹¤.
 * íŒŒì¼ì˜ ì²« ë²ˆì§¸ /// ì£¼ì„ì„ ì°¾ì•„ì„œ ê·¸ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
 */
function extractModuleNameFromComment(text: string): string | null {
    const lines = text.split(/\r?\n/);

    for (const line of lines) {
        const trimmed = line.trim();

        // ì²« ë²ˆì§¸ /// ì£¼ì„ì„ ì°¾ìœ¼ë©´ ê·¸ ê°’ì„ ë°˜í™˜
        if (trimmed.startsWith('///')) {
            const moduleName = trimmed.substring(3).trim();
            if (moduleName) {
                return moduleName;
            }
        }

        // ë¹ˆ ì¤„ì´ ì•„ë‹Œ ë‹¤ë¥¸ ë‚´ìš©ì´ ë‚˜ì˜¤ë©´ ë” ì´ìƒ ì°¾ì§€ ì•ŠìŒ
        if (trimmed && !trimmed.startsWith('//') && !trimmed.startsWith('///')) {
            break;
        }
    }

    return null;
}

