import { Tree, SchematicContext } from "@angular-devkit/schematics";

export interface PrismaModelField {
    name: string;
    type: string;
    optional: boolean;
    description?: string;
    isArray?: boolean;
    isId?: boolean;
    isAutoGenerated?: boolean;
}

export interface PrismaModel {
    name: string;
    fields: PrismaModelField[];
    moduleName?: string;
}

/**
 * Prisma ìŠ¤í‚¤ë§ˆ íŒŒì¼ì—ì„œ ëª¨ë¸ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
 * ëª¨ë“ˆ ì´ë¦„ê³¼ ì¼ì¹˜í•˜ëŠ” ëª¨ë¸ì„ ìš°ì„ ì ìœ¼ë¡œ ì°¾ê³ , ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ ëª¨ë¸ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
export function parsePrismaModel(
    tree: Tree,
    context: SchematicContext,
    prismaPath: string,
    targetModelName?: string
): PrismaModel | undefined {
    const buf = tree.read(prismaPath);
    if (!buf) {
        context.logger.warn(`Could not read prisma file: ${prismaPath}`);
        return undefined;
    }

    const text = buf.toString("utf-8");

    // íŒŒì¼ ìƒë‹¨ì˜ /// ì£¼ì„ì—ì„œ MODULE_NAME ì¶”ì¶œ
    const moduleName = extractModuleNameFromComment(text);

    // ëª¨ë“  ëª¨ë¸ ë¸”ë¡ ì°¾ê¸°
    const allModelRegex = /model\s+(\w+)\s+\{([\s\S]*?)\}/gm;
    const models: Array<{ name: string; body: string }> = [];
    let match;

    while ((match = allModelRegex.exec(text)) !== null) {
        if (match[1] && match[2]) {
            models.push({
                name: match[1],
                body: match[2],
            });
        }
    }

    if (models.length === 0) {
        context.logger.warn(`No model block found in ${prismaPath}`);
        return undefined;
    }

    // íƒ€ê²Ÿ ëª¨ë¸ ì´ë¦„ì´ ìˆìœ¼ë©´ í•´ë‹¹ ëª¨ë¸ ì°¾ê¸°
    let selectedModel = models[0];

    if (!selectedModel) {
        context.logger.warn(`No model found in ${prismaPath}`);
        return undefined;
    }

    if (targetModelName) {
        const found = models.find(
            (m) =>
                m.name.toLowerCase() === targetModelName.toLowerCase() ||
                m.name.toLowerCase() === targetModelName.toLowerCase() + "s" ||
                m.name.toLowerCase() + "s" === targetModelName.toLowerCase()
        );
        if (found) {
            selectedModel = found;
            context.logger.info(
                `âœ… Found matching model '${found.name}' for '${targetModelName}'`
            );
        } else {
            context.logger.warn(
                `âš ï¸  No model matching '${targetModelName}' found. Using first model '${selectedModel.name}'`
            );
        }
    }

    const fields: PrismaModelField[] = parseModelFields(
        selectedModel.body,
        context
    );

    context.logger.info(
        `âœ… Parsed model '${selectedModel.name}' with ${fields.length} field(s)`
    );

    if (moduleName) {
        context.logger.info(`ğŸ“ Module name extracted from comment: ${moduleName}`);
    }

    const result: PrismaModel = {
        name: selectedModel.name,
        fields
    };

    if (moduleName) {
        result.moduleName = moduleName;
    }

    return result;
}

/**
 * ëª¨ë¸ ë³¸ë¬¸ì—ì„œ í•„ë“œë“¤ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
function parseModelFields(
    body: string,
    context: SchematicContext
): PrismaModelField[] {
    const fields: PrismaModelField[] = [];
    const lines = body.split(/\r?\n/);
    // ìˆ˜ì •ëœ ì •ê·œì‹: íƒ€ì…ì—ì„œ ?ë¥¼ ì œê±°í•˜ê³  ë³„ë„ë¡œ ì²´í¬
    const lineRegex = /^\s*(\w+)\s+([A-Za-z_][A-Za-z0-9_]*)(\[\])?\??/;

    // Create DTOì—ì„œ ìë™ ì œì™¸í•  í•„ë“œë“¤
    const autoExcludeFields = ["id", "createdAt", "updatedAt", "deletedAt"];

    // Prisma scalar íƒ€ì… ì •ì˜
    const scalarTypes = [
        "String",
        "Int",
        "Float",
        "Decimal",
        "BigInt",
        "Boolean",
        "DateTime",
        "Json",
        "Bytes",
    ];

    function getBaseType(type: string): string {
        return type.endsWith("[]") ? type.slice(0, -2) : type.replace("?", "");
    }

    for (const line of lines) {
        const trimmed = line.trim();

        // ë¹ˆ ì¤„, ì£¼ì„, ë°ì½”ë ˆì´í„° ìŠ¤í‚µ
        if (
            !trimmed ||
            trimmed.startsWith("//") ||
            trimmed.startsWith("@@") ||
            trimmed.startsWith("}")
        ) {
            continue;
        }

        const m = trimmed.match(lineRegex);
        if (!m) {
            continue;
        }

        const fName = m[1] ?? "";
        const fType = m[2] ?? "any";
        const hasArray = Boolean(m[3]);

        // ? ìœ„ì¹˜ í™•ì¸ìœ¼ë¡œ optional íŒë³„
        const hasOptional = trimmed.includes("?");
        const optionalPos = trimmed.indexOf("?");
        const arrayPos = trimmed.indexOf("[]");
        // String[]? ëŠ” optional, String? ë„ optional
        const isOptional = hasOptional && (!hasArray || optionalPos > arrayPos);
        const isArray = hasArray;

        // ë¦´ë ˆì´ì…˜ í•„ë“œ ìŠ¤í‚µ (ëŒ€ë¬¸ìë¡œ ì‹œì‘í•˜ëŠ” íƒ€ì… + @relation ìˆëŠ” ê²½ìš°)
        if (/\@relation\b/.test(trimmed)) {
            context.logger.debug(`Skipping relation field: ${fName}`);
            continue;
        }

        // ë² ì´ìŠ¤ íƒ€ì… ì¶”ì¶œ
        const baseType = getBaseType(fType);

        // ë¦´ë ˆì´ì…˜ íƒ€ì… í•„ë“œ ìŠ¤í‚µ (Prisma scalar íƒ€ì…ì´ ì•„ë‹Œ ê²½ìš°)
        if (!scalarTypes.includes(fType) && !scalarTypes.includes(baseType)) {
            context.logger.debug(
                `Skipping non-scalar field: ${fName} (type: ${fType})`
            );
            continue;
        }

        // @id ì†ì„± ì²´í¬
        const isId = /@id\b/.test(trimmed);

        // ìë™ ìƒì„± í•„ë“œ ì²´í¬
        const isAutoGenerated = isAutoGeneratedField(trimmed, fName);

        // ì¸ë¼ì¸ ì£¼ì„ ì¶”ì¶œ (/// ë˜ëŠ” //)
        let description: string | undefined;
        const tripleSlashMatch = trimmed.match(/\/\/\/\s*(.+)$/);
        const doubleSlashMatch = trimmed.match(/\/\/\s*(.+)$/);

        if (tripleSlashMatch) {
            description = tripleSlashMatch[1]?.trim();
        } else if (doubleSlashMatch) {
            description = doubleSlashMatch[1]?.trim();
        }

        const field: PrismaModelField = {
            name: fName,
            type: isArray ? `${fType}[]` : fType,
            optional: isOptional,
            isArray,
            isId,
            isAutoGenerated,
        };

        if (description) {
            field.description = description;
        }

        fields.push(field);

        // í•„ë“œ ë¶„ë¥˜ ì •ë³´ ë¡œê¹…
        const fieldType = isId ? "ID" : isAutoGenerated ? "AUTO" : isOptional ? "OPTIONAL" : "REQUIRED";
        const excludeInfo = autoExcludeFields.includes(fName) ? " (EXCLUDED)" : "";

        context.logger.debug(
            `âœ“ Parsed field: ${fName} (${fType}${isOptional ? "?" : ""}) [${fieldType}]${excludeInfo} - ${description || "no description"}`
        );
    }

    context.logger.info(`ğŸ“‹ Total fields parsed: ${fields.length}`);
    return fields;
}

/**
 * í•„ë“œê°€ ìë™ ìƒì„± í•„ë“œì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
 * @default, @updatedAt, @dbgenerated ë“±ì˜ ë°ì½”ë ˆì´í„°ë¥¼ ì²´í¬í•©ë‹ˆë‹¤.
 */
function isAutoGeneratedField(fieldLine: string, fieldName: string): boolean {
    // @updatedAt ë°ì½”ë ˆì´í„° ì²´í¬
    if (/@updatedAt\b/.test(fieldLine)) {
        return true;
    }

    // @default ë°ì½”ë ˆì´í„° ì²´í¬
    if (/@default\b/.test(fieldLine)) {
        return true;
    }

    // @dbgenerated ë°ì½”ë ˆì´í„° ì²´í¬
    if (/@dbgenerated\b/.test(fieldLine)) {
        return true;
    }

    // ì¼ë°˜ì ì¸ ìë™ ìƒì„± í•„ë“œëª… íŒ¨í„´ ì²´í¬
    const autoGeneratedFieldNames = [
        'id', 'createdAt', 'updatedAt', 'deletedAt',
        'created_at', 'updated_at', 'deleted_at'
    ];

    if (autoGeneratedFieldNames.includes(fieldName.toLowerCase())) {
        return true;
    }

    return false;
}

/**
 * í”„ë¦¬ì¦ˆë§ˆ íŒŒì¼ ìƒë‹¨ì˜ /// ì£¼ì„ì—ì„œ MODULE_NAMEì„ ì¶”ì¶œí•©ë‹ˆë‹¤.
 * íŒŒì¼ì˜ ì²« ë²ˆì§¸ /// ì£¼ì„ì„ ì°¾ì•„ì„œ ê·¸ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
 */
function extractModuleNameFromComment(text: string): string | null {
    const lines = text.split(/\r?\n/);

    for (const line of lines) {
        const trimmed = line.trim();

        // ì²« ë²ˆì§¸ /// ì£¼ì„ì„ ì°¾ìœ¼ë©´ ê·¸ ê°’ì„ ë°˜í™˜
        if (trimmed.startsWith('///')) {
            const moduleName = trimmed.substring(3).trim();
            if (moduleName) {
                return moduleName;
            }
        }

        // ë¹ˆ ì¤„ì´ ì•„ë‹Œ ë‹¤ë¥¸ ë‚´ìš©ì´ ë‚˜ì˜¤ë©´ ë” ì´ìƒ ì°¾ì§€ ì•ŠìŒ
        if (trimmed && !trimmed.startsWith('//') && !trimmed.startsWith('///')) {
            break;
        }
    }

    return null;
}

