import { Tree, SchematicContext } from "@angular-devkit/schematics";

export interface PrismaModelField {
    name: string;
    type: string;
    optional: boolean;
    description?: string;
    isArray?: boolean;
    isId?: boolean;
    isAutoGenerated?: boolean;
}

export interface PrismaModel {
    name: string;
    fields: PrismaModelField[];
    moduleName?: string;
}

/**
 * Prisma 스키마 파일에서 모델을 파싱합니다.
 * 모듈 이름과 일치하는 모델을 우선적으로 찾고, 없으면 첫 번째 모델을 사용합니다.
 */
export function parsePrismaModel(
    tree: Tree,
    context: SchematicContext,
    prismaPath: string,
    targetModelName?: string
): PrismaModel | undefined {
    const buf = tree.read(prismaPath);
    if (!buf) {
        context.logger.warn(`Could not read prisma file: ${prismaPath}`);
        return undefined;
    }

    const text = buf.toString("utf-8");

    // 파일 상단의 /// 주석에서 MODULE_NAME 추출
    const moduleName = extractModuleNameFromComment(text);

    // 모든 모델 블록 찾기
    const allModelRegex = /model\s+(\w+)\s+\{([\s\S]*?)\}/gm;
    const models: Array<{ name: string; body: string }> = [];
    let match;

    while ((match = allModelRegex.exec(text)) !== null) {
        if (match[1] && match[2]) {
            models.push({
                name: match[1],
                body: match[2],
            });
        }
    }

    if (models.length === 0) {
        context.logger.warn(`No model block found in ${prismaPath}`);
        return undefined;
    }

    // 타겟 모델 이름이 있으면 해당 모델 찾기
    let selectedModel = models[0];

    if (!selectedModel) {
        context.logger.warn(`No model found in ${prismaPath}`);
        return undefined;
    }

    if (targetModelName) {
        const found = models.find(
            (m) =>
                m.name.toLowerCase() === targetModelName.toLowerCase() ||
                m.name.toLowerCase() === targetModelName.toLowerCase() + "s" ||
                m.name.toLowerCase() + "s" === targetModelName.toLowerCase()
        );
        if (found) {
            selectedModel = found;
            context.logger.info(
                `✅ Found matching model '${found.name}' for '${targetModelName}'`
            );
        } else {
            context.logger.warn(
                `⚠️  No model matching '${targetModelName}' found. Using first model '${selectedModel.name}'`
            );
        }
    }

    const fields: PrismaModelField[] = parseModelFields(
        selectedModel.body,
        context
    );

    context.logger.info(
        `✅ Parsed model '${selectedModel.name}' with ${fields.length} field(s)`
    );

    if (moduleName) {
        context.logger.info(`📝 Module name extracted from comment: ${moduleName}`);
    }

    const result: PrismaModel = {
        name: selectedModel.name,
        fields
    };

    if (moduleName) {
        result.moduleName = moduleName;
    }

    return result;
}

/**
 * 모델 본문에서 필드들을 파싱합니다.
 */
function parseModelFields(
    body: string,
    context: SchematicContext
): PrismaModelField[] {
    const fields: PrismaModelField[] = [];
    const lines = body.split(/\r?\n/);
    // 수정된 정규식: 타입에서 ?를 제거하고 별도로 체크
    const lineRegex = /^\s*(\w+)\s+([A-Za-z_][A-Za-z0-9_]*)(\[\])?\??/;

    // Create DTO에서 자동 제외할 필드들
    const autoExcludeFields = ["id", "createdAt", "updatedAt", "deletedAt"];

    // Prisma scalar 타입 정의
    const scalarTypes = [
        "String",
        "Int",
        "Float",
        "Decimal",
        "BigInt",
        "Boolean",
        "DateTime",
        "Json",
        "Bytes",
    ];

    function getBaseType(type: string): string {
        return type.endsWith("[]") ? type.slice(0, -2) : type.replace("?", "");
    }

    for (const line of lines) {
        const trimmed = line.trim();

        // 빈 줄, 주석, 데코레이터 스킵
        if (
            !trimmed ||
            trimmed.startsWith("//") ||
            trimmed.startsWith("@@") ||
            trimmed.startsWith("}")
        ) {
            continue;
        }

        const m = trimmed.match(lineRegex);
        if (!m) {
            continue;
        }

        const fName = m[1] ?? "";
        const fType = m[2] ?? "any";
        const hasArray = Boolean(m[3]);

        // ? 위치 확인으로 optional 판별
        const hasOptional = trimmed.includes("?");
        const optionalPos = trimmed.indexOf("?");
        const arrayPos = trimmed.indexOf("[]");
        // String[]? 는 optional, String? 도 optional
        const isOptional = hasOptional && (!hasArray || optionalPos > arrayPos);
        const isArray = hasArray;

        // 릴레이션 필드 스킵 (대문자로 시작하는 타입 + @relation 있는 경우)
        if (/\@relation\b/.test(trimmed)) {
            context.logger.debug(`Skipping relation field: ${fName}`);
            continue;
        }

        // 베이스 타입 추출
        const baseType = getBaseType(fType);

        // 릴레이션 타입 필드 스킵 (Prisma scalar 타입이 아닌 경우)
        if (!scalarTypes.includes(fType) && !scalarTypes.includes(baseType)) {
            context.logger.debug(
                `Skipping non-scalar field: ${fName} (type: ${fType})`
            );
            continue;
        }

        // @id 속성 체크
        const isId = /@id\b/.test(trimmed);

        // 자동 생성 필드 체크
        const isAutoGenerated = isAutoGeneratedField(trimmed, fName);

        // 인라인 주석 추출 (/// 또는 //)
        let description: string | undefined;
        const tripleSlashMatch = trimmed.match(/\/\/\/\s*(.+)$/);
        const doubleSlashMatch = trimmed.match(/\/\/\s*(.+)$/);

        if (tripleSlashMatch) {
            description = tripleSlashMatch[1]?.trim();
        } else if (doubleSlashMatch) {
            description = doubleSlashMatch[1]?.trim();
        }

        const field: PrismaModelField = {
            name: fName,
            type: isArray ? `${fType}[]` : fType,
            optional: isOptional,
            isArray,
            isId,
            isAutoGenerated,
        };

        if (description) {
            field.description = description;
        }

        fields.push(field);

        // 필드 분류 정보 로깅
        const fieldType = isId ? "ID" : isAutoGenerated ? "AUTO" : isOptional ? "OPTIONAL" : "REQUIRED";
        const excludeInfo = autoExcludeFields.includes(fName) ? " (EXCLUDED)" : "";

        context.logger.debug(
            `✓ Parsed field: ${fName} (${fType}${isOptional ? "?" : ""}) [${fieldType}]${excludeInfo} - ${description || "no description"}`
        );
    }

    context.logger.info(`📋 Total fields parsed: ${fields.length}`);
    return fields;
}

/**
 * 필드가 자동 생성 필드인지 확인합니다.
 * @default, @updatedAt, @dbgenerated 등의 데코레이터를 체크합니다.
 */
function isAutoGeneratedField(fieldLine: string, fieldName: string): boolean {
    // @updatedAt 데코레이터 체크
    if (/@updatedAt\b/.test(fieldLine)) {
        return true;
    }

    // @default 데코레이터 체크
    if (/@default\b/.test(fieldLine)) {
        return true;
    }

    // @dbgenerated 데코레이터 체크
    if (/@dbgenerated\b/.test(fieldLine)) {
        return true;
    }

    // 일반적인 자동 생성 필드명 패턴 체크
    const autoGeneratedFieldNames = [
        'id', 'createdAt', 'updatedAt', 'deletedAt',
        'created_at', 'updated_at', 'deleted_at'
    ];

    if (autoGeneratedFieldNames.includes(fieldName.toLowerCase())) {
        return true;
    }

    return false;
}

/**
 * 프리즈마 파일 상단의 /// 주석에서 MODULE_NAME을 추출합니다.
 * 파일의 첫 번째 /// 주석을 찾아서 그 값을 반환합니다.
 */
function extractModuleNameFromComment(text: string): string | null {
    const lines = text.split(/\r?\n/);

    for (const line of lines) {
        const trimmed = line.trim();

        // 첫 번째 /// 주석을 찾으면 그 값을 반환
        if (trimmed.startsWith('///')) {
            const moduleName = trimmed.substring(3).trim();
            if (moduleName) {
                return moduleName;
            }
        }

        // 빈 줄이 아닌 다른 내용이 나오면 더 이상 찾지 않음
        if (trimmed && !trimmed.startsWith('//') && !trimmed.startsWith('///')) {
            break;
        }
    }

    return null;
}

