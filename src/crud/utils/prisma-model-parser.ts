import { Tree, SchematicContext } from "@angular-devkit/schematics";

export interface PrismaModelField {
    name: string;
    type: string;
    optional: boolean;
    description?: string;
    isArray?: boolean;
    isId?: boolean;
    isAutoGenerated?: boolean;
}

export interface PrismaModel {
    name: string;
    fields: PrismaModelField[];
}

/**
 * Prisma ìŠ¤í‚¤ë§ˆ íŒŒì¼ì—ì„œ ëª¨ë¸ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
 * ëª¨ë“ˆ ì´ë¦„ê³¼ ì¼ì¹˜í•˜ëŠ” ëª¨ë¸ì„ ìš°ì„ ì ìœ¼ë¡œ ì°¾ê³ , ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ ëª¨ë¸ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
export function parsePrismaModel(
    tree: Tree,
    context: SchematicContext,
    prismaPath: string,
    targetModelName?: string
): PrismaModel | undefined {
    const buf = tree.read(prismaPath);
    if (!buf) {
        context.logger.warn(`Could not read prisma file: ${prismaPath}`);
        return undefined;
    }

    const text = buf.toString("utf-8");

    // ëª¨ë“  ëª¨ë¸ ë¸”ë¡ ì°¾ê¸°
    const allModelRegex = /model\s+(\w+)\s+\{([\s\S]*?)\}/gm;
    const models: Array<{ name: string; body: string }> = [];
    let match;

    while ((match = allModelRegex.exec(text)) !== null) {
        if (match[1] && match[2]) {
            models.push({
                name: match[1],
                body: match[2],
            });
        }
    }

    if (models.length === 0) {
        context.logger.warn(`No model block found in ${prismaPath}`);
        return undefined;
    }

    // íƒ€ê²Ÿ ëª¨ë¸ ì´ë¦„ì´ ìˆìœ¼ë©´ í•´ë‹¹ ëª¨ë¸ ì°¾ê¸°
    let selectedModel = models[0];

    if (!selectedModel) {
        context.logger.warn(`No model found in ${prismaPath}`);
        return undefined;
    }

    if (targetModelName) {
        const found = models.find(
            (m) =>
                m.name.toLowerCase() === targetModelName.toLowerCase() ||
                m.name.toLowerCase() === targetModelName.toLowerCase() + "s" ||
                m.name.toLowerCase() + "s" === targetModelName.toLowerCase()
        );
        if (found) {
            selectedModel = found;
            context.logger.info(
                `âœ… Found matching model '${found.name}' for '${targetModelName}'`
            );
        } else {
            context.logger.warn(
                `âš ï¸  No model matching '${targetModelName}' found. Using first model '${selectedModel.name}'`
            );
        }
    }

    const fields: PrismaModelField[] = parseModelFields(
        selectedModel.body,
        context
    );

    context.logger.info(
        `âœ… Parsed model '${selectedModel.name}' with ${fields.length} field(s)`
    );
    return { name: selectedModel.name, fields };
}

/**
 * ëª¨ë¸ ë³¸ë¬¸ì—ì„œ í•„ë“œë“¤ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
function parseModelFields(
    body: string,
    context: SchematicContext
): PrismaModelField[] {
    const fields: PrismaModelField[] = [];
    const lines = body.split(/\r?\n/);
    // ìˆ˜ì •ëœ ì •ê·œì‹: íƒ€ì…ì—ì„œ ?ë¥¼ ì œê±°í•˜ê³  ë³„ë„ë¡œ ì²´í¬
    const lineRegex = /^\s*(\w+)\s+([A-Za-z_][A-Za-z0-9_]*)(\[\])?\??/;

    // Prisma scalar íƒ€ì… ì •ì˜
    const scalarTypes = [
        "String",
        "Int",
        "Float",
        "Decimal",
        "BigInt",
        "Boolean",
        "DateTime",
        "Json",
        "Bytes",
    ];

    function getBaseType(type: string): string {
        return type.endsWith("[]") ? type.slice(0, -2) : type.replace("?", "");
    }

    for (const line of lines) {
        const trimmed = line.trim();

        // ë¹ˆ ì¤„, ì£¼ì„, ë°ì½”ë ˆì´í„° ìŠ¤í‚µ
        if (
            !trimmed ||
            trimmed.startsWith("//") ||
            trimmed.startsWith("@@") ||
            trimmed.startsWith("}")
        ) {
            continue;
        }

        const m = trimmed.match(lineRegex);
        if (!m) {
            continue;
        }

        const fName = m[1] ?? "";
        const fType = m[2] ?? "any";
        const hasArray = Boolean(m[3]);

        // ? ìœ„ì¹˜ í™•ì¸ìœ¼ë¡œ optional íŒë³„
        const hasOptional = trimmed.includes("?");
        const optionalPos = trimmed.indexOf("?");
        const arrayPos = trimmed.indexOf("[]");
        // String[]? ëŠ” optional, String? ë„ optional
        const isOptional = hasOptional && (!hasArray || optionalPos > arrayPos);
        const isArray = hasArray;

        // ë¦´ë ˆì´ì…˜ í•„ë“œ ìŠ¤í‚µ (ëŒ€ë¬¸ìë¡œ ì‹œì‘í•˜ëŠ” íƒ€ì… + @relation ìˆëŠ” ê²½ìš°)
        if (/\@relation\b/.test(trimmed)) {
            context.logger.debug(`Skipping relation field: ${fName}`);
            continue;
        }

        // ë² ì´ìŠ¤ íƒ€ì… ì¶”ì¶œ
        const baseType = getBaseType(fType);

        // ë¦´ë ˆì´ì…˜ íƒ€ì… í•„ë“œ ìŠ¤í‚µ (Prisma scalar íƒ€ì…ì´ ì•„ë‹Œ ê²½ìš°)
        if (!scalarTypes.includes(fType) && !scalarTypes.includes(baseType)) {
            context.logger.debug(
                `Skipping non-scalar field: ${fName} (type: ${fType})`
            );
            continue;
        }

        // @id ì†ì„± ì²´í¬
        const isId = /@id\b/.test(trimmed);

        // @default ë˜ëŠ” @updatedAt ì²´í¬ (ìë™ ìƒì„± í•„ë“œ)
        const isAutoGenerated =
            /@default\b/.test(trimmed) || /@updatedAt\b/.test(trimmed);

        // ì¸ë¼ì¸ ì£¼ì„ ì¶”ì¶œ (/// ë˜ëŠ” //)
        let description: string | undefined;
        const tripleSlashMatch = trimmed.match(/\/\/\/\s*(.+)$/);
        const doubleSlashMatch = trimmed.match(/\/\/\s*(.+)$/);

        if (tripleSlashMatch) {
            description = tripleSlashMatch[1]?.trim();
        } else if (doubleSlashMatch) {
            description = doubleSlashMatch[1]?.trim();
        }

        const field: PrismaModelField = {
            name: fName,
            type: isArray ? `${fType}[]` : fType,
            optional: isOptional,
            isArray,
            isId,
            isAutoGenerated,
        };

        if (description) {
            field.description = description;
        }

        fields.push(field);
        context.logger.debug(
            `âœ“ Parsed field: ${fName} (${fType}${isOptional ? "?" : ""}) - ${description || "no description"}`
        );
    }

    context.logger.info(`ğŸ“‹ Total fields parsed: ${fields.length}`);
    return fields;
}

